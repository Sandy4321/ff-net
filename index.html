<!DOCTYPE html>
<html>
<head>
<charset="utf-8">
<link rel="stylesheet" type="text/css" href="css/style.css" charset="utf-8">
<script src="lib/d3/d3.js" charset="utf-8"></script>
<script src="js/Vector2.js" charset="utf-8"></script>
<script src="js/Link.js" charset="utf-8"></script>
<script src="js/Spike.js" charset="utf-8"></script>
<script src="js/Neuron.js" charset="utf-8"></script>
<script src="js/NeuralNet.js" charset="utf-8"></script>

<script>

function init() {
	var trainingSet = [
		{x: [0.5, 0.25], y: 1},
		{x: [0.6, 0.23], y: 1},
		{x: [0.4, 0.21], y: 1},
		{x: [0.45, 0.11], y: 1},
		{x: [0.88, 0.32], y: 1},
		{x: [0.08, 0.24], y: 1},
		{x: [0.2, 0.27], y: 1},
		{x: [0.05, 0.30], y: 1},
		{x: [0.1, 0.1], y: 1},

		{x: [0.1, 0.41], y: 0},
		{x: [0.2, 0.42], y: 0},
		{x: [0.15, 0.53], y: 0},
		{x: [0.1, 0.54], y: 0},

		{x: [0.9, 0.9], y: 0},
		{x: [0.9, 0.8], y: 0},
		{x: [0.8, 0.7], y: 0},

		{x: [0.06, 0.87], y: 0},
		{x: [0.09, 0.8], y: 0},
		{x: [0.4, 0.9], y: 0},

		{x: [0.59, 0.5], y: 0},
		{x: [0.39, 0.3], y: 0},
		{x: [0.57, 0.4], y: 0}
	];

	var svgWidth = 340;
	var svgHeight = 250;
	var canvasWidth = 250;
	var canvasHeight = 250;
	var neuronRadius = 12;
	var maxSpikeRadius = 5;
	var preactivationTop = 5;
	var minOutputPaint = 0.5 - 0;
	var maxOutputPaint = 0.5 + 0;

	var neuralNet = new NeuralNet();
	var dy = 70;
	neuralNet.addNeuron(new Vector2(20, svgHeight/2 - dy*0.5), -9999);//0
	neuralNet.addNeuron(new Vector2(20, svgHeight/2 + dy*0.5), -9999);//1

	neuralNet.addNeuron(new Vector2(120, svgHeight/2 - dy*1.5), 0);//2
	neuralNet.addNeuron(new Vector2(120, svgHeight/2 - dy*0.5), 0);//3
	neuralNet.addNeuron(new Vector2(120, svgHeight/2 + dy*0.5), 0);//4
	neuralNet.addNeuron(new Vector2(120, svgHeight/2 + dy*1.5), 0);//5

	neuralNet.addNeuron(new Vector2(220, svgHeight/2 - dy*1.5), 0);//6
	neuralNet.addNeuron(new Vector2(220, svgHeight/2 - dy*0.5), 0);//7
	neuralNet.addNeuron(new Vector2(220, svgHeight/2 + dy*0.5), 0);//8
	neuralNet.addNeuron(new Vector2(220, svgHeight/2 + dy*1.5), 0);//9

	neuralNet.addNeuron(new Vector2(320, svgHeight/2), 0);//10


	neuralNet.addLink(neuralNet.neurons[0], neuralNet.neurons[2], 1);
	neuralNet.addLink(neuralNet.neurons[0], neuralNet.neurons[3], 1);
	neuralNet.addLink(neuralNet.neurons[0], neuralNet.neurons[4], -0.9);
	neuralNet.addLink(neuralNet.neurons[0], neuralNet.neurons[5], -5);

	neuralNet.addLink(neuralNet.neurons[1], neuralNet.neurons[2], -3);
	neuralNet.addLink(neuralNet.neurons[1], neuralNet.neurons[3], 5);
	neuralNet.addLink(neuralNet.neurons[1], neuralNet.neurons[4], 2);
	neuralNet.addLink(neuralNet.neurons[1], neuralNet.neurons[5], 5);

	neuralNet.addLink(neuralNet.neurons[2], neuralNet.neurons[6], 5);
	neuralNet.addLink(neuralNet.neurons[2], neuralNet.neurons[7], 5);
	neuralNet.addLink(neuralNet.neurons[2], neuralNet.neurons[8], -2);
	neuralNet.addLink(neuralNet.neurons[2], neuralNet.neurons[9], 5);

	neuralNet.addLink(neuralNet.neurons[3], neuralNet.neurons[6], 1);
	neuralNet.addLink(neuralNet.neurons[3], neuralNet.neurons[7], -2);
	neuralNet.addLink(neuralNet.neurons[3], neuralNet.neurons[8], -3);
	neuralNet.addLink(neuralNet.neurons[3], neuralNet.neurons[9], 1);

	neuralNet.addLink(neuralNet.neurons[4], neuralNet.neurons[6], -2.5);
	neuralNet.addLink(neuralNet.neurons[4], neuralNet.neurons[8], -2.5);
	neuralNet.addLink(neuralNet.neurons[4], neuralNet.neurons[7], 1);
	neuralNet.addLink(neuralNet.neurons[4], neuralNet.neurons[9], 5);

	neuralNet.addLink(neuralNet.neurons[5], neuralNet.neurons[6], -2.5);
	neuralNet.addLink(neuralNet.neurons[5], neuralNet.neurons[7], 2.5);
	neuralNet.addLink(neuralNet.neurons[5], neuralNet.neurons[8], -2.5);
	neuralNet.addLink(neuralNet.neurons[5], neuralNet.neurons[9], -2.5);

	neuralNet.addLink(neuralNet.neurons[6], neuralNet.neurons[10], 2.7);
	neuralNet.addLink(neuralNet.neurons[7], neuralNet.neurons[10], -2.5);
	neuralNet.addLink(neuralNet.neurons[8], neuralNet.neurons[10], -1);
	neuralNet.addLink(neuralNet.neurons[9], neuralNet.neurons[10], 3);

	neuralNet.input = [neuralNet.neurons[0], neuralNet.neurons[1]];
	neuralNet.output = [neuralNet.neurons[10]];

	var svg = d3.select('body')
	.append('svg')
	.attr('width', svgWidth)
	.attr('height', svgHeight);

	var canvasDiv = d3.select('body')
	.append('div')
	.style('position', 'relative');

	var canvas = canvasDiv.append('canvas')
	.attr('width', canvasWidth)
	.attr('height', canvasHeight);

	var ctx = canvas.node().getContext('2d');

	var canvasSvg = canvasDiv.append('svg')
	.attr('width', canvasWidth)
	.attr('height', canvasHeight)
	.style('position', 'absolute')
	.style('left', '0px')
	.style('top', '0px')
	.style('z-index', '2');

	var d3Link = svg.append('svg:g').selectAll('path');
	var d3Spike = svg.append('svg:g').selectAll('g');
	var d3Neuron = svg.append('svg:g').selectAll('g');
	var d3Sample = canvasSvg.append('svg:g').selectAll('g');

	var t = 0;
	var propagationT = 200;

	restart();

	var firstPass = true;
	var firingNeurons = [];
	/*
	firingNeurons = neuralNet.input;
	neuralNet.neurons[0].activation = 0.8;
	neuralNet.neurons[1].activation = 0.8;
	*/

	neuralNet.reset();
	setInterval(tick, 1 / 30);

	function tick() {
		neuralNet.train(trainingSet);
		updateCanvas();

		if (t >= propagationT) {
			t = propagationT;
			var newFiringNeurons = [];
			for (var i = 0; i < firingNeurons.length; i++) {
				var neuron = firingNeurons[i];
				for (var j = 0; j < neuron.links.length; j++) {
					var link = neuron.links[j];
					if (newFiringNeurons.indexOf(link.nf) == -1) {
						newFiringNeurons.push(link.nf);
					}
				}
			}
			firingNeurons = newFiringNeurons;
			t = 0;
		} else
		if (t == 0) {
			if (firstPass) {
				firstPass = false;
			} else {
				for (var i = 0; i < firingNeurons.length; i++) {
					var neuron = firingNeurons[i];
					neuron.update();
				}
			}

			for (var i = 0; i < firingNeurons.length; i++) {
				var neuron = firingNeurons[i];
				for (var j = 0; j < firingNeurons[i].links.length; j++) {
					var spike = neuron.links[j].spike;
					spike.radius = maxSpikeRadius * Math.min(1, Math.abs(spike.getMagnitude()) / preactivationTop);
				}
			}

			t++;
		} else {
			t++;
		}

		for (var i = 0; i < firingNeurons.length; i++) {
			for (var j = 0; j < firingNeurons[i].links.length; j++) {
				var spike = firingNeurons[i].links[j].spike;
				var link = spike.link;

				var v = link.nf.pos.subtract(link.n0.pos).normalize();
				var p0 = link.n0.pos.add(v.times(neuronRadius - spike.radius));
				var pf = link.nf.pos.subtract(v.times(neuronRadius - spike.radius));
				v = pf.subtract(p0);
				spike.pos = p0.add(v.times(t / propagationT));
			}
		}

		// draw directed edges with proper padding from node centers
		d3Link.attr('d', function(d) {
			var deltaX = d.nf.pos.x - d.n0.pos.x,
				deltaY = d.nf.pos.y - d.n0.pos.y,
				dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
				normX = deltaX / dist,
				normY = deltaY / dist,
				sourcePadding = d.left ? neuronRadius - 5 : neuronRadius,
				targetPadding = d.right ? neuronRadius - 5: neuronRadius,
				sourceX = d.n0.pos.x + (sourcePadding * normX),
				sourceY = d.n0.pos.y + (sourcePadding * normY),
				targetX = d.nf.pos.x - (targetPadding * normX),
				targetY = d.nf.pos.y - (targetPadding * normY);
			return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
		});

		d3Neuron.attr('transform', function(d) {
			return 'translate(' + d.pos.x + ',' + d.pos.y + ')';
		})
		.selectAll('circle').style('fill', function(d) {
			var v = Math.abs(d.activation);
			return d3.rgb(
				(1 - v) * 255,
				0,
				v * 255
				);
		});

		d3Link
		.style('stroke-width', function(d) {
			return maxSpikeRadius * 2 * Math.min(1, Math.abs(d.weight) / preactivationTop);
		});

		d3Spike.attr('transform', function(d) {
			return 'translate(' + d.pos.x + ',' + d.pos.y + ')';
		});
		d3Spike.selectAll('circle').attr('r', function(d) { return d.radius; });
	}

	function restart() {
		var g;

		d3Link = d3Link.data(neuralNet.links);

		d3Link.enter().append('svg:path')
		.attr('class', 'link')
		.style('stroke-width', function(d) {
			return 1; // maxSpikeRadius * 2 * Math.min(1, Math.abs(d.weight) / preactivationTop);
		})
		.style('stroke', function(d) {
			if (d.weight > 0) {
				return d3.rgb(0, 0, 255);
			} else {
				return d3.rgb(255, 0, 0);
			}
		})
		.style('stroke-opacity', function(d) { return 0.3; });

		d3Link.exit().remove();

		d3Neuron = d3Neuron.data(neuralNet.neurons);
		g = d3Neuron.enter().append('svg:g');

		g.append('svg:circle')
		.attr('class', 'neuron')
		.attr('r', neuronRadius)
		.style('fill', function(d) { return d3.rgb(250, 250, 200); })
		.style('stroke', function(d) { return d3.rgb(0, 0, 0); });

		d3Neuron.exit().remove();

		d3Spike = d3Spike.data(neuralNet.spikes);
		g = d3Spike.enter().append('svg:g');

		g.append('svg:circle')
		.attr('class', 'spike')
		.attr('fill', function(d) {
			if (d.link.weight > 0) {
				return d3.rgb(0, 0, 200);
			} else {
				return d3.rgb(200, 0, 0);
			}
		});

		d3Spike.exit().remove();

		d3Sample = d3Sample.data(trainingSet);
		g = d3Sample.enter().append('svg:g');

		g.append('svg:circle')
		.attr('class', 'sample')
		.attr('r', 5)
		.style('stroke', function(d) { return d3.rgb(0, 0, 0) })
		.style('fill', function(d) {
			if (d.y == 1) return d3.rgb(0, 0, 255);
			else return d3.rgb(255, 0, 0);
		});

		d3Sample.attr('transform', function(d) {
			return 'translate(' + d.x[0] * canvasWidth + ',' + d.x[1] * canvasHeight + ')';
		});

		d3Sample.exit().remove();

		updateCanvas();

	}

	function updateCanvas() {
		for (var i = 0; i < canvasWidth; i++) {
			for (var j = 0; j < canvasHeight; j++) {
				var output = neuralNet.computeOutput([i / canvasWidth, j / canvasHeight]);
				var v = output[0];
				if (v > maxOutputPaint) ctx.fillStyle = d3.rgb(0, 0, 255);
				else if (v < minOutputPaint) ctx.fillStyle = d3.rgb(255, 0, 0);
				else {
					v = (v - minOutputPaint) / (maxOutputPaint - minOutputPaint);
					ctx.fillStyle = d3.rgb(255 * (1 - v), 0, 255 * (v));
				}

				ctx.fillRect(i, j, 1, 1);
			}
		}
	}

}

</script>

</head>
<body onload="init()">
</body>
</html>
